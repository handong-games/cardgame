# Unity C# 코딩 컨벤션 (AI/팀 공용)

> 본 문서는 Unity 프로젝트의 C# 코드 스타일을 **일관되게 유지**하기 위한 규칙집입니다.  
> 최우선 가치: **가독성 > 일관성 > 개인 취향**.  
> 가능하면 IDE/Formatter의 자동 서식을 존중합니다.

---

## 1. 적용 범위

- Unity 프로젝트의 모든 C# 코드(런타임/에디터/툴링 포함)
- 단, 외부 라이브러리/자동 생성 코드는 예외로 합니다.

---

## 2. 포맷팅 기본 원칙

- 팀에서 합의한 IDE 서식(예: Visual Studio / Rider 자동 포맷)을 기본으로 합니다.
- **중괄호/들여쓰기/줄바꿈**은 자동 포맷 결과를 우선합니다.
- 접근 제한자(`public`, `private`, `protected`, `internal`)는 **항상 명시**합니다.

---

## 3. 네이밍 규칙

### 3.1 케이스 규칙 요약

| 대상 | 규칙 | 예시 |
|---|---|---|
| 클래스/구조체/네임스페이스 | PascalCase | `PlayerController`, `MyGame.UI` |
| public 메서드 | PascalCase | `GetHealth()` |
| non-public 메서드 | camelCase | `rebuildCache()` |
| 매개변수/지역변수 | camelCase | `maxHealth` |
| private 필드 | `_` + camelCase | `_maxHealth` |
| 프로퍼티 | PascalCase | `Health`, `IsDead` |
| 인터페이스 | `I` + PascalCase | `IDamageable` |
| enum 타입 | `E` + PascalCase | `EDirection` |
| enum 멤버 | PascalCase | `North` |

---

### 3.2 Bool 네이밍 (Unity 권장)

- bool은 반드시 **질문형 의미**를 갖도록 네이밍합니다.
- 접두사: `is / has / can / should`
- `bDead`, `flag`, `check` 같은 네이밍은 금지합니다.

```csharp
private bool _isDead;
public bool CanAttack { get; private set; }
```

---

### 3.3 메서드 네이밍 (포프킴 스타일)

- **동사 + 목적어** 형태를 기본으로 합니다.
- bool 반환 메서드는 `Is/Can/Has/Should`로 시작합니다.
- public: PascalCase / non-public: camelCase

```csharp
public void ApplyDamage(int amount);
private void rebuildCache();
```

---

### 3.4 Unity 전용 메서드 네이밍 (허용)

의미가 분명한 동사 세트를 **허용**합니다(강제는 아님).

- 입력 처리: `HandleXxx`
- 상태 갱신: `UpdateXxx`
- 캐시/표시 재구성: `RefreshXxx` / `RebuildXxx`
- UI 반응: `OnClickXxx`(UI 버튼 콜백 등, “이벤트 발생용 OnXxx”와 구분)

```csharp
private void HandleMoveInput();
private void UpdateTargetLock();
private void RefreshHud();
```

---

### 3.5 이벤트 규칙 (OnXxx 패턴 강제)

- **이벤트 발생 메서드**는 반드시 `OnXxx` 형태를 사용합니다.
- 이벤트 자체는 **과거형/명사형**으로 작성합니다.

```csharp
public event Action Damaged;

private void OnDamaged()
{
    Damaged?.Invoke();
}
```

---

## 4. 파일 / 스크립트 규칙 (Unity)

### 4.1 MonoBehaviour 파일 규칙 (강제)

- MonoBehaviour가 포함된 파일은 **파일당 1개**
- 파일명 = MonoBehaviour 클래스명

```text
PlayerController.cs
 └ PlayerController : MonoBehaviour
```

---

## 5. SerializeField / Header / 주석 규칙

### 5.1 SerializeField 네이밍

- `[SerializeField]` 필드도 **private `_camelCase`** 규칙을 유지합니다.
- public 필드 노출은 금지합니다.

```csharp
[SerializeField] private int _maxHealth;
```

---

### 5.2 Header 규칙 (강제)

- Inspector에서 의미 있는 단위로 **[Header]를 반드시 사용**합니다.
- Header 문자열은 **사용자 관점 명사형**으로 작성합니다.

```csharp
[Header("Health Settings")]
[SerializeField] private int _maxHealth;
[SerializeField] private int _regenRate;
```

---

### 5.3 주석 규칙

- **왜(Why)** 를 설명하는 주석만 작성합니다.
- 코드로 설명 가능한 **무엇/어떻게**는 주석으로 쓰지 않습니다.

```csharp
// 서버와 클라이언트 로직 분기 필요
if (isServer)
{
    ...
}
```

---

## 6. API 경계 / Validation 규칙 (강제)

- 외부 입력 → 내부 진입 지점에서만 validate
- 내부 로직은 **유효하다고 가정**하고 작성
- 가정은 `Debug.Assert()`로 명시

```csharp
Debug.Assert(target != null);
```

---

## 7. null 정책 (Nullable Reference Types)

- null 가능성은 타입(`string?`)으로 표현합니다.
- `TryGetXxx` 패턴 적극 사용
- `OrNull` 네이밍은 강제하지 않습니다.

---

## 8. var 사용 규칙

- `var`는 **원칙적으로 사용 금지**
- 익명 타입 등 불가피한 경우만 예외 허용

---

## 9. Unity 메시지 함수 정렬 규칙

- 아래 순서를 유지합니다:

1. `Awake`
2. `OnEnable`
3. `Start`
4. `Update`
5. `LateUpdate`
6. `FixedUpdate`
7. `OnDisable`
8. `OnDestroy`

---

## 10. Editor / Runtime 분리 규칙 ( #if UNITY_EDITOR 필요 )

에디터 전용 코드는 **빌드에 포함되지 않도록** 반드시 분리합니다.

### 10.1 권장 구조

- `Assets/**/Editor/` 폴더에 Editor 코드를 둡니다(가능하면 이 방식 우선).
- 단, **런타임 타입에 Editor 보조 기능을 같이 두어야 하는 경우**(예: Custom Inspector가 같은 파일 근처에 있어야 유지보수가 쉬운 팀 규칙 등)에는 `#if UNITY_EDITOR`를 사용합니다.

### 10.2 #if UNITY_EDITOR 사용 규칙 (강제)

- `using UnityEditor;` 는 **반드시** `#if UNITY_EDITOR`로 감쌉니다.
- Editor 전용 타입/메서드는 `#if UNITY_EDITOR` 블록 내부에만 둡니다.
- 런타임 코드가 Editor API에 직접 의존하지 않도록 합니다.

```csharp
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    [SerializeField] private int _maxHealth;

#if UNITY_EDITOR
    private void OnDrawGizmosSelected()
    {
        // 에디터에서만 시각화
        Gizmos.DrawWireSphere(transform.position, 1.0f);
    }
#endif
}

#if UNITY_EDITOR
using UnityEditor;

[CustomEditor(typeof(PlayerController))]
public class PlayerControllerEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
    }
}
#endif
```

---

## 11. Region 정책 (금지)

- `#region` / `#endregion` 는 **사용 금지**합니다.
- 코드 구조는 “파일 분리”, “클래스 멤버 정렬”, “명확한 네이밍”으로 해결합니다.

---

## 12. 클래스 멤버 정렬 순서

1. 필드
2. 프로퍼티
3. 생성자
4. 메서드 (public → private)

---

## 13. 체크리스트 (AI / PR 공용)

- [ ] 접근 제한자를 항상 명시했는가?
- [ ] private 필드가 `_camelCase`인가?
- [ ] bool이 질문형 네이밍인가?
- [ ] enum 타입에 `E` 접두사가 있는가?
- [ ] 이벤트 발생 메서드가 `OnXxx`인가?
- [ ] MonoBehaviour 파일 규칙을 지켰는가?
- [ ] Header / SerializeField 규칙을 지켰는가?
- [ ] Editor 코드를 `Editor/` 폴더 또는 `#if UNITY_EDITOR`로 분리했는가?
- [ ] `#region`을 사용하지 않았는가?

---
