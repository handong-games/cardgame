# Addressables 리소스 관리

Unity 카드게임 프로젝트의 Addressables 기반 에셋 관리 전략 문서

---

## 1. 개요

### 1.1 문서 목적
- Addressables 시스템을 활용한 체계적인 에셋 관리
- 메모리 최적화 및 로딩 성능 개선
- 원격 업데이트/패치 시스템 구축

### 1.2 Addressables 선택 이유
| 장점 | 설명 |
|------|------|
| 동적 에셋 로딩 | 필요한 시점에 에셋 로드/언로드 가능 |
| 메모리 효율 | 참조 카운팅 기반 자동 메모리 관리 |
| 원격 업데이트 | 앱 업데이트 없이 에셋 교체 가능 |
| 에셋 번들 관리 | 그룹별 번들링으로 효율적 패키징 |

### 1.3 프로젝트 에셋 규모 (현재 기준)
| 카테고리 | 수량 | 비고 |
|---------|------|------|
| 카드 | 약 20종 | 클래스별 분류 |
| 적 | 11종 | 슬라임, 고블린, 해골기사 등 |
| 클래스 | 4종 | 전사, 기사, 궁수, 마법사 |
| 버프 | 약 10종 | 공격력 증가, 방어력 감소 등 |

---

## 2. 에셋 그룹 구성

### 2.1 그룹 분류 전략
```
Addressables Groups/
├── Local_Static          # 빌드에 포함 (항상 필요)
├── Local_Dynamic         # 빌드에 포함 (필요 시 로드/언로드)
├── Remote_Audio          # 서버에서 다운로드 (오디오)
└── Remote_DLC            # 서버에서 다운로드 (추가 콘텐츠)
```

### 2.2 Local_Static 그룹
**빌드 포함, 항상 메모리 유지**

| 포함 에셋 | 설명 |
|----------|------|
| ScriptableObjects | CardData, EnemyData, BuffData, ClassData |
| Core Prefabs | 카드 프리팹, UI 프리팹 |
| Fonts | 게임 폰트 |
| Common Sprites | 아이콘, UI 프레임 |

**빌드 설정:**
- Bundle Mode: Pack Together
- Compression: LZMA (최대 압축)
- Load Path: LocalBuildPath

### 2.3 Local_Dynamic 그룹
**빌드 포함, 필요 시 로드/언로드**

| 포함 에셋 | 설명 |
|----------|------|
| Card Sprites | 카드 일러스트 |
| Enemy Sprites | 적 일러스트 |
| Effect Sprites | 이펙트 스프라이트 |
| UI Sprites | 씬별 UI 스프라이트 |

**빌드 설정:**
- Bundle Mode: Pack Separately (카테고리별)
- Compression: LZ4 (빠른 로드)
- Load Path: LocalBuildPath

### 2.4 Remote 그룹 (선택사항)
**서버에서 다운로드**

| 그룹 | 포함 에셋 | 용도 |
|------|----------|------|
| Remote_Audio | BGM, SFX | 용량 절감 |
| Remote_DLC | 추가 카드팩, 신규 클래스 | 콘텐츠 확장 |

**빌드 설정:**
- Bundle Mode: Pack Together
- Compression: LZ4
- Load Path: RemoteLoadPath (CDN URL)

### 2.5 그룹별 예상 용량

| 그룹 | 예상 용량 | 비고 |
|------|----------|------|
| Local_Static | 5-10 MB | SO + 폰트 + 공통 |
| Local_Dynamic | 20-50 MB | 스프라이트 |
| Remote_Audio | 50-100 MB | BGM + SFX |
| Remote_DLC | 가변 | 콘텐츠에 따라 |

---

## 3. 주소 지정 규칙 (Addressing Convention)

### 3.1 네이밍 컨벤션
- 소문자 + 언더스코어 사용 (snake_case)
- 계층 구조는 슬래시(/) 구분
- 확장자 제외

### 3.2 카드 에셋 주소
```
Cards/Data/{CardKey}           → CardSO
Cards/Sprites/{CardKey}        → 카드 일러스트

예시:
Cards/Data/strike              → 타격 카드 데이터
Cards/Data/defend              → 방어 카드 데이터
Cards/Sprites/strike           → 타격 카드 아트
Cards/Sprites/heavy_strike     → 강타 카드 아트
```

### 3.3 적(Enemy) 에셋 주소
```
Enemies/Data/{EnemyKey}        → EnemySO
Enemies/Sprites/{EnemyKey}     → 적 일러스트

예시:
Enemies/Data/slime             → 슬라임 데이터
Enemies/Data/goblin            → 고블린 데이터
Enemies/Sprites/skeleton_king  → 해골왕 스프라이트
```

### 3.4 클래스/버프 에셋 주소
```
Classes/{ClassName}/Data       → ClassSO
Buffs/Data/{BuffKey}           → BuffSO

예시:
Classes/warrior/Data           → 전사 클래스 데이터
Classes/paladin/Data           → 팔라딘 클래스 데이터
Buffs/Data/strength            → 힘 버프 데이터
```

### 3.5 UI/공통 에셋 주소
```
UI/Prefabs/{Name}              → UI 프리팹
UI/Sprites/{Category}/{Name}   → UI 스프라이트

예시:
UI/Prefabs/card_prefab         → 카드 UI 프리팹
UI/Prefabs/hp_bar              → HP 바 프리팹
UI/Sprites/icons/energy        → 에너지 아이콘
UI/Sprites/frames/card_frame   → 카드 프레임
```

### 3.6 오디오 에셋 주소
```
Audio/BGM/{Name}               → 배경음악
Audio/SFX/{Category}/{Name}    → 효과음

예시:
Audio/BGM/battle_theme         → 전투 테마
Audio/BGM/village_theme        → 마을 테마
Audio/SFX/card/play            → 카드 사용 효과음
Audio/SFX/card/draw            → 카드 드로우 효과음
Audio/SFX/combat/hit           → 타격 효과음
Audio/SFX/combat/shield        → 방어 효과음
```

---

## 4. 메모리 관리 전략

### 4.1 씬별 메모리 예산

| 씬 | 예산 | 주요 에셋 |
|----|------|----------|
| Boot | 10 MB | 필수 SO, 폰트, 공통 UI |
| MainMenu | 30 MB | 메뉴 UI, BGM |
| Battle | 80 MB | 카드, 적, 이펙트, SFX |
| Village | 50 MB | NPC, 시설 UI |
| Reward | 40 MB | 보상 카드 미리보기 |

### 4.2 에셋 로드/언로드 시점

```
[Boot 씬]
  └→ Addressables 초기화
  └→ 공통 SO 프리로드 (모든 CardSO, EnemySO, BuffSO)
     → SO는 가벼우므로 전체 로드 유지

[MainMenu 진입]
  └→ 메뉴 UI 스프라이트 로드
  └→ 메뉴 BGM 로드

[Battle 씬 진입]
  └→ 현재 덱 카드 스프라이트 로드
  └→ 해당 라운드 적 스프라이트 로드
  └→ 전투 BGM 로드
  └→ 공통 SFX 프리로드 (카드/전투 효과음)

[라운드 전환]
  └→ 이전 적 스프라이트 해제
  └→ 다음 적 스프라이트 로드

[보상 선택]
  └→ 보상 카드 3장 스프라이트 지연 로드
  └→ 선택하지 않은 카드 스프라이트 즉시 해제

[Battle 씬 종료]
  └→ 전투 전용 스프라이트 전체 해제
  └→ 전투 SFX 해제
  └→ 전투 BGM 해제
```

### 4.3 에셋 참조 카운팅
Addressables는 참조 카운팅 기반 메모리 관리를 제공합니다.

```csharp
// 로드 - 참조 카운트 +1
AsyncOperationHandle<Sprite> handle =
    Addressables.LoadAssetAsync<Sprite>("Cards/Sprites/strike");

// 해제 - 참조 카운트 -1
Addressables.Release(handle);

// 참조 카운트가 0이 되면 자동으로 메모리에서 해제
```

**주의사항:**
- 로드 횟수만큼 Release 호출 필요
- 씬 전환 시 미해제 에셋 확인

### 4.4 메모리 풀링 패턴

```
[카드 오브젝트 풀]
┌─────────────────────────────────────┐
│ CardViewPool                        │
├─────────────────────────────────────┤
│ - 최대 풀 크기: 12개 (핸드 10 + 버퍼)│
│ - Acquire(): 풀에서 꺼내거나 생성   │
│ - Return(): 비활성화 후 풀에 반환   │
│ - Cleanup(): 씬 전환 시 풀 정리     │
└─────────────────────────────────────┘

[적 오브젝트 풀]
┌─────────────────────────────────────┐
│ EnemyViewPool                       │
├─────────────────────────────────────┤
│ - 최대 풀 크기: 5개 (동시 적 최대 4)│
│ - 라운드 전환 시 재활용             │
└─────────────────────────────────────┘

[이펙트 오브젝트 풀]
┌─────────────────────────────────────┐
│ EffectPool                          │
├─────────────────────────────────────┤
│ - 타입별 풀 관리 (피격, 버프 등)    │
│ - 재생 완료 후 자동 반환            │
└─────────────────────────────────────┘
```

### 4.5 GC 최적화

| 전략 | 설명 |
|------|------|
| 풀링 활용 | Instantiate/Destroy 최소화 |
| 캐싱 | 자주 사용하는 에셋 핸들 캐싱 |
| 배치 해제 | 여러 에셋 일괄 해제 |
| 씬 전환 시 정리 | Resources.UnloadUnusedAssets() 호출 |

---

## 5. 로딩 시스템

### 5.1 씬별 로딩 전략

| 씬 전환 | 로딩 방식 | 설명 |
|---------|----------|------|
| Boot → MainMenu | 동기식 | 빠른 초기화, 로딩 화면 불필요 |
| MainMenu → Battle | 비동기 + 로딩 화면 | 프리로딩 필요 |
| Battle 내 라운드 전환 | 백그라운드 | 끊김 없는 전환 |
| Battle → Village | 비동기 + 페이드 | 중간 규모 로딩 |
| Village → Battle | 비동기 + 로딩 화면 | 새 전투 준비 |

### 5.2 비동기 로딩 패턴

```
[배틀 씬 프리로드 순서]
1. 덱 내 모든 카드 스프라이트 (병렬 로드)
2. 현재 라운드 적 스프라이트
3. 전투 BGM
4. 공통 SFX 프리로드

[로딩 진행률 계산]
총 진행률 = (완료된 에셋 수 / 총 에셋 수) × 100

예시 (덱 카드 10장, 적 1, BGM 1, SFX 5):
총 에셋 = 10 + 1 + 1 + 5 = 17
로드 완료 13개 → 진행률 = 76%
```

### 5.3 프리로딩 전략

**즉시 프리로드 (Boot 씬):**
- 모든 ScriptableObject (CardSO, EnemySO, BuffSO)
- 공통 UI 스프라이트 (아이콘, 프레임)
- 폰트

**지연 프리로드 (해당 씬 진입 시):**
- 씬별 스프라이트
- 오디오 클립

### 5.4 백그라운드 로딩

```
[라운드 전환 시 백그라운드 로딩]
현재 라운드 진행 중:
  └→ 다음 라운드 적 정보 확인
  └→ 백그라운드에서 다음 적 스프라이트 로드
  └→ 라운드 종료 시 즉시 전환 가능

[보상 선택 전 백그라운드 로딩]
전투 종료 직후:
  └→ 보상 후보 카드 결정
  └→ 백그라운드에서 3장 스프라이트 로드
  └→ 보상 화면 전환 시 즉시 표시
```

---

## 6. 로딩 UX

### 6.1 로딩 화면 디자인

```
┌─────────────────────────────────────────────────────┐
│                                                     │
│                                                     │
│         ┌───────────────────────────────┐           │
│         │                               │           │
│         │   [카드 일러스트 랜덤 표시]    │           │
│         │                               │           │
│         └───────────────────────────────┘           │
│                                                     │
│     ═══════════════════════════════════════════     │
│     [████████████████████░░░░░░░░] 75%              │
│                                                     │
│     ┌───────────────────────────────────────┐       │
│     │  Tip: 오라 카드를 먼저 사용하면       │       │
│     │       공격 카드의 데미지가 증가합니다 │       │
│     └───────────────────────────────────────┘       │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 6.2 프로그레스 바 구현

**구성 요소:**
- 배경 바 (회색)
- 진행 바 (그라데이션/단색)
- 퍼센트 텍스트 (선택)
- 로딩 아이콘 애니메이션 (선택)

**진행률 업데이트:**
- 실제 에셋 로딩 진행률 반영
- 부드러운 보간 (Lerp) 적용
- 급격한 점프 방지

### 6.3 로딩 팁/힌트 시스템

**팁 카테고리:**
| 카테고리 | 예시 |
|---------|------|
| 전투 전략 | "오라 카드를 먼저 사용하면 공격력이 증가합니다" |
| 카드 조합 | "방어 카드와 보호막 카드를 함께 사용해보세요" |
| 전직 정보 | "팔라딘은 신성 계열 카드를 강화합니다" |
| 게임 팁 | "상점에서 카드를 제거하면 덱이 효율적이 됩니다" |

**표시 방식:**
- 랜덤 선택
- 3-5초 간격 전환
- 페이드 인/아웃 효과

### 6.4 최소 로딩 시간 보장

```
최소 로딩 시간: 1.5초

이유:
- 너무 빠른 깜빡임 방지
- 로딩 팁 읽을 시간 확보
- 일관된 사용자 경험

구현:
실제 로딩 시간 < 1.5초 → 나머지 시간 대기
실제 로딩 시간 >= 1.5초 → 즉시 전환
```

---

## 7. 업데이트/패치 시스템

### 7.1 원격 에셋 다운로드

**초기 설정:**
```
[RemoteLoadPath 설정]
- 개발: http://localhost:8080/[BuildTarget]/[AppVersion]
- 프로덕션: https://cdn.example.com/[BuildTarget]/[AppVersion]
```

**다운로드 플로우:**
```
[앱 시작]
  └→ 카탈로그 업데이트 확인
  └→ 업데이트 있음?
      ├→ Yes: 다운로드 크기 표시 → 사용자 확인 → 다운로드
      └→ No: 게임 시작
```

### 7.2 카탈로그 버전 관리

```
[버전 네이밍]
catalog_v{Major}.{Minor}.{Patch}.json

예시:
catalog_v1.0.0.json  → 초기 릴리즈
catalog_v1.0.1.json  → 버그 픽스 (에셋 수정)
catalog_v1.1.0.json  → 신규 카드 추가
catalog_v2.0.0.json  → 대규모 업데이트

[버전 호환성]
Major 변경: 앱 업데이트 필요 (구조 변경)
Minor 변경: 콘텐츠 추가 (호환)
Patch 변경: 에셋 수정 (호환)
```

### 7.3 핫픽스 시나리오별 대응

| 수정 범위 | 전략 | 재시작 필요 |
|-----------|------|-------------|
| 카드 밸런스 (SO 수정) | 카탈로그 업데이트 | O (다음 실행 시) |
| 스프라이트 교체 | 해당 번들만 교체 | X (다음 로드 시) |
| 신규 카드 추가 | 새 번들 다운로드 | X |
| 버그 픽스 (코드) | 앱 업데이트 | O |
| 긴급 패치 | 강제 업데이트 플래그 | O |

### 7.4 캐싱 정책

```
[로컬 캐시 구조]
/Addressables/
  ├── catalog_cache/          # 카탈로그 캐시
  │   └── catalog_{hash}.json
  ├── local_bundles/          # 로컬 번들 (빌드 포함)
  └── remote_bundles/         # 다운로드된 원격 번들
      ├── cards_{hash}.bundle
      ├── audio_{hash}.bundle
      └── dlc_{hash}.bundle

[캐시 만료 정책]
- 카탈로그: 앱 시작 시 항상 체크
- 오디오 번들: 7일 미사용 시 삭제 후보
- DLC 번들: 사용자 명시적 삭제만 허용

[캐시 크기 제한]
- 최대 캐시: 500 MB
- 초과 시 LRU(Least Recently Used) 방식 정리
```

### 7.5 다운로드 실패 처리

```
[재시도 로직]
시도 1 실패 → 2초 대기 → 시도 2
시도 2 실패 → 5초 대기 → 시도 3
시도 3 실패 → 에러 표시, 사용자 선택 요청

[사용자 선택 옵션]
- 재시도: 처음부터 다시 시도
- 건너뛰기: 해당 에셋 없이 진행 (가능한 경우)
- 취소: 이전 화면으로 돌아가기

[오프라인 모드]
- 로컬 캐시된 에셋으로 플레이
- Remote 그룹 에셋 비활성화
- "오프라인 모드" 표시
```

---

## 8. 구현 가이드

### 8.1 초기 설정

**1. Addressables 패키지 설치**
```
Window > Package Manager > Unity Registry > Addressables
```

**2. Addressables 초기화**
```
Window > Asset Management > Addressables > Groups
```

**3. 프로필 설정**
- Development: 로컬 빌드, 빠른 반복
- Production: 최적화 빌드, CDN 경로

### 8.2 핵심 매니저 클래스

```
[AddressablesManager]
역할: Addressables 시스템 전체 관리
주요 메서드:
  - Initialize(): 시스템 초기화
  - LoadAssetAsync<T>(address): 단일 에셋 로드
  - LoadAssetsAsync<T>(addresses): 복수 에셋 병렬 로드
  - ReleaseAsset(handle): 에셋 해제
  - GetLoadProgress(): 현재 로딩 진행률

[CardAssetLoader]
역할: 카드 관련 에셋 로드 전담
주요 메서드:
  - LoadCardData(cardKey): CardSO 로드
  - LoadCardSprite(cardKey): 카드 스프라이트 로드
  - PreloadDeckSprites(deck): 덱 전체 스프라이트 프리로드
  - ReleaseCardSprite(cardKey): 스프라이트 해제

[EnemyAssetLoader]
역할: 적 관련 에셋 로드 전담
주요 메서드:
  - LoadEnemyData(enemyKey): EnemySO 로드
  - LoadEnemySprite(enemyKey): 적 스프라이트 로드
  - PreloadRoundEnemies(round): 라운드 적 프리로드

[AudioAssetLoader]
역할: 오디오 에셋 로드 전담
주요 메서드:
  - LoadBGM(bgmName): BGM 로드
  - LoadSFX(category, sfxName): SFX 로드
  - PreloadBattleSFX(): 전투 공통 SFX 프리로드
  - ReleaseBGM(bgmName): BGM 해제
```

### 8.3 에셋 참조 방식

**AssetReference 사용 (권장):**
```
ScriptableObject에서 스프라이트 참조 시:
- 직접 참조 대신 AssetReference 사용
- 필요 시점에 로드, 사용 후 해제
- 에디터에서 드래그 앤 드롭으로 할당
```

**주소 문자열 사용:**
```
동적으로 주소 생성 필요 시:
- 규칙 기반 주소 생성
- 예: $"Cards/Sprites/{cardKey}"
```

### 8.4 에디터 도구

**Addressables Profiler:**
```
Window > Asset Management > Addressables > Event Viewer
- 에셋 로드/언로드 이벤트 모니터링
- 참조 카운트 확인
- 메모리 누수 디버깅
```

**Analyze 도구:**
```
Window > Asset Management > Addressables > Analyze
- 번들 중복 확인
- 종속성 분석
- 빌드 사이즈 리포트
```

---

## 9. 카드게임 특화 최적화

### 9.1 카드 스프라이트 아틀라스

```
[아틀라스 구성]
Cards_Common.atlas     → 기본 카드 (타격, 방어 등)
Cards_Paladin.atlas    → 팔라딘 전용 카드
Cards_Warrior.atlas    → 전사 전용 카드
Cards_Archer.atlas     → 궁수 전용 카드
Cards_Mage.atlas       → 마법사 전용 카드
UI_CardFrame.atlas     → 카드 프레임, 코스트 아이콘

[장점]
- 드로우 콜 감소 (배치 렌더링)
- 텍스처 메모리 효율
- 로딩 시간 단축

[설정]
- 최대 아틀라스 크기: 2048x2048
- 패딩: 2px (밉맵 블리딩 방지)
- 압축: Crunch Compression
```

### 9.2 ScriptableObject 프리로딩 전략

```
[Boot 씬에서 전체 프리로드]
모든 CardSO (약 20개)    → 각 1KB 미만
모든 EnemySO (11개)      → 각 1KB 미만
모든 BuffSO (약 10개)    → 각 0.5KB 미만
모든 ClassSO (4개)       → 각 2KB 미만

총 예상: 50KB 미만

[이유]
- SO는 데이터만 포함 (스프라이트 제외)
- 전투 중 동적 로딩 지연 없음
- 참조 관계 미리 설정
- 메모리 부담 최소
```

### 9.3 전투 씬 최적화

**카드 핸드 최적화:**
```
[핸드 구성]
- 최대 핸드 크기: 10장
- 카드 프리팹 풀: 12개 유지
- 스프라이트는 CardSO에서 AssetReference로 참조

[카드 드로우 시]
1. 풀에서 CardView 획득
2. CardSO 할당 (이미 로드됨)
3. 스프라이트 AssetReference 로드 (캐시된 경우 즉시)
4. UI 업데이트
```

**적 전환 최적화:**
```
[라운드 전환 시]
현재 상태: 적 A 표시 중
다음 라운드: 적 B 예정

1. 적 B 스프라이트 백그라운드 로드 시작
2. 라운드 종료 연출 (0.5초)
3. 적 B 스프라이트 로드 완료 확인
4. 적 A 스프라이트 해제
5. 적 B 표시
```

### 9.4 보상 카드 지연 로딩

```
[보상 선택 화면]
1. 보상 후보 3장 결정 (CardSO는 이미 로드됨)
2. 3장 스프라이트 병렬 로드 (0.1-0.3초)
3. 로드 완료 후 카드 표시
4. 사용자 선택
5. 선택되지 않은 2장 스프라이트 즉시 해제
6. 선택된 카드는 덱에 추가 (스프라이트 유지)
```

---

## 10. 구현 로드맵

### Phase 1: 기본 설정 (1-2일)
- [ ] Addressables 패키지 설치
- [ ] 에셋 그룹 생성 (Local_Static, Local_Dynamic)
- [ ] 주소 지정 규칙 적용 (기존 에셋에 주소 할당)
- [ ] AddressablesManager 스켈레톤 구현
- [ ] 에디터에서 기본 로드/언로드 테스트

### Phase 2: 핵심 기능 (3-5일)
- [ ] CardAssetLoader 구현
- [ ] EnemyAssetLoader 구현
- [ ] 전투 씬 프리로딩 시스템 구현
- [ ] 로딩 화면 UI 구현
- [ ] 프로그레스 바 연동
- [ ] 오브젝트 풀링 시스템 구현
- [ ] 메모리 프로파일링 및 최적화

### Phase 3: 고급 기능 (5-7일)
- [ ] AudioAssetLoader 구현
- [ ] Remote 그룹 설정 (CDN 연동)
- [ ] 카탈로그 업데이트 시스템
- [ ] 다운로드 실패 처리/재시도 로직
- [ ] 캐시 관리 시스템
- [ ] 로딩 팁 시스템

### Phase 4: 최적화 및 확장 (선택)
- [ ] 스프라이트 아틀라스 최적화
- [ ] DLC 카탈로그 분리
- [ ] 분석 도구 연동
- [ ] 성능 벤치마크

---

## 부록

### A. 에셋 주소 목록 (예시)

**카드:**
| 카드 키 | 데이터 주소 | 스프라이트 주소 |
|--------|------------|----------------|
| strike | Cards/Data/strike | Cards/Sprites/strike |
| defend | Cards/Data/defend | Cards/Sprites/defend |
| heavy_strike | Cards/Data/heavy_strike | Cards/Sprites/heavy_strike |

**적:**
| 적 키 | 데이터 주소 | 스프라이트 주소 |
|------|------------|----------------|
| slime | Enemies/Data/slime | Enemies/Sprites/slime |
| goblin | Enemies/Data/goblin | Enemies/Sprites/goblin |
| skeleton_king | Enemies/Data/skeleton_king | Enemies/Sprites/skeleton_king |

### B. 트러블슈팅

| 증상 | 원인 | 해결 |
|------|------|------|
| 에셋 로드 실패 | 주소 오타 | 주소 확인, Addressables Groups에서 검색 |
| 메모리 누수 | Release 미호출 | Event Viewer로 참조 카운트 확인 |
| 빌드 후 로드 실패 | 빌드 설정 오류 | Build > Clean Build 후 재빌드 |
| 원격 다운로드 실패 | CDN 경로 오류 | RemoteLoadPath 프로필 확인 |

### C. 참고 자료

- [Unity Addressables 공식 문서](https://docs.unity3d.com/Packages/com.unity.addressables@latest)
- [Addressables 베스트 프랙티스](https://unity.com/how-to/simplify-your-content-management-addressables)
- [메모리 프로파일링 가이드](https://docs.unity3d.com/Manual/ProfilerMemory.html)

---

## 변경 이력

| 날짜 | 버전 | 변경 내용 |
|------|------|----------|
| 2026-01-13 | 1.0 | 초기 문서 작성 (unity-project-architecture.md에서 분리) |
